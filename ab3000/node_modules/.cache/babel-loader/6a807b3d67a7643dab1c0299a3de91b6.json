{"ast":null,"code":"import { polygonLength } from \"d3-polygon\";\nimport { polygonCentroid, interpolatePoints, distance, isFiniteNumber } from \"./math.js\";\nimport normalizeRing from \"./normalize.js\";\nimport { addPoints } from \"./add.js\";\nimport { toPathString } from \"./svg.js\";\nexport function fromCircle(x, y, radius, toShape, options) {\n  return fromShape(circlePoints(x, y, radius), toShape, circlePath(x, y, radius), 2 * Math.PI * radius, options);\n}\nexport function toCircle(fromShape, x, y, radius, options) {\n  let interpolator = fromCircle(x, y, radius, fromShape, options);\n  return t => interpolator(1 - t);\n}\nexport function fromRect(x, y, width, height, toShape, options) {\n  return fromShape(rectPoints(x, y, width, height), toShape, rectPath(x, y, width, height), 2 * width + 2 * height, options);\n}\nexport function toRect(fromShape, x, y, width, height, options) {\n  let interpolator = fromRect(x, y, width, height, fromShape, options);\n  return t => interpolator(1 - t);\n}\n\nfunction fromShape(fromFn, toShape, original, perimeter, {\n  maxSegmentLength = 10,\n  string = true\n} = {}) {\n  let toRing = normalizeRing(toShape, maxSegmentLength),\n      fromRing,\n      interpolator; // Enforce maxSegmentLength on circle/rect perimeter too\n\n  if (isFiniteNumber(perimeter) && toRing.length < perimeter / maxSegmentLength) {\n    addPoints(toRing, Math.ceil(perimeter / maxSegmentLength - toRing.length));\n  }\n\n  fromRing = fromFn(toRing);\n  interpolator = interpolatePoints(fromRing, toRing, string);\n\n  if (string) {\n    return t => t < 1e-4 ? original : interpolator(t);\n  }\n\n  return interpolator;\n}\n\nexport function circlePoints(x, y, radius) {\n  return function (ring) {\n    let centroid = polygonCentroid(ring),\n        perimeter = polygonLength([...ring, ring[0]]),\n        startingAngle = Math.atan2(ring[0][1] - centroid[1], ring[0][0] - centroid[0]),\n        along = 0;\n    return ring.map((point, i) => {\n      let angle;\n\n      if (i) {\n        along += distance(point, ring[i - 1]);\n      }\n\n      angle = startingAngle + 2 * Math.PI * (perimeter ? along / perimeter : i / ring.length);\n      return [Math.cos(angle) * radius + x, Math.sin(angle) * radius + y];\n    });\n  };\n} // TODO splice in exact corners?\n\nexport function rectPoints(x, y, width, height) {\n  return function (ring) {\n    let centroid = polygonCentroid(ring),\n        perimeter = polygonLength([...ring, ring[0]]),\n        startingAngle = Math.atan2(ring[0][1] - centroid[1], ring[0][0] - centroid[0]),\n        along = 0;\n\n    if (startingAngle < 0) {\n      startingAngle = 2 * Math.PI + startingAngle;\n    }\n\n    let startingProgress = startingAngle / (2 * Math.PI);\n    return ring.map((point, i) => {\n      if (i) {\n        along += distance(point, ring[i - 1]);\n      }\n\n      let relative = rectPoint((startingProgress + (perimeter ? along / perimeter : i / ring.length)) % 1);\n      return [x + relative[0] * width, y + relative[1] * height];\n    });\n  };\n} // TODO don't do this\n\nfunction rectPoint(progress) {\n  if (progress <= 1 / 8) {\n    return [1, 0.5 + progress * 4];\n  }\n\n  if (progress <= 3 / 8) {\n    return [1.5 - 4 * progress, 1];\n  }\n\n  if (progress <= 5 / 8) {\n    return [0, 2.5 - 4 * progress];\n  }\n\n  if (progress <= 7 / 8) {\n    return [4 * progress - 2.5, 0];\n  }\n\n  return [1, 4 * progress - 3.5];\n}\n\nexport function circlePath(x, y, radius) {\n  let l = x - radius + \",\" + y,\n      r = x + radius + \",\" + y,\n      pre = \"A\" + radius + \",\" + radius + \",0,1,1,\";\n  return \"M\" + l + pre + r + pre + l + \"Z\";\n}\nexport function rectPath(x, y, width, height) {\n  let r = x + width,\n      b = y + height;\n  return \"M\" + x + \",\" + y + \"L\" + r + \",\" + y + \"L\" + r + \",\" + b + \"L\" + x + \",\" + b + \"Z\";\n}","map":null,"metadata":{},"sourceType":"module"}