{"ast":null,"code":"import { neighbors, mergeArcs, feature } from \"topojson-client\";\nimport { polygonArea } from \"d3-polygon\";\nimport { bisector } from \"d3-array\"; // TODO use TopoJSON native instead?\n\nexport function createTopology(triangles, ring) {\n  const arcIndices = {},\n        topology = {\n    type: \"Topology\",\n    objects: {\n      triangles: {\n        type: \"GeometryCollection\",\n        geometries: []\n      }\n    },\n    arcs: []\n  };\n  triangles.forEach(function (triangle) {\n    const geometry = [];\n    triangle.forEach(function (arc, i) {\n      const slug = arc[0] < arc[1] ? arc.join(\",\") : arc[1] + \",\" + arc[0],\n            coordinates = arc.map(function (pointIndex) {\n        return ring[pointIndex];\n      });\n\n      if (slug in arcIndices) {\n        geometry.push(~arcIndices[slug]);\n      } else {\n        geometry.push(arcIndices[slug] = topology.arcs.length);\n        topology.arcs.push(coordinates);\n      }\n    });\n    topology.objects.triangles.geometries.push({\n      type: \"Polygon\",\n      area: Math.abs(polygonArea(triangle.map(function (d) {\n        return ring[d[0]];\n      }))),\n      arcs: [geometry]\n    });\n  }); // Sort smallest first\n  // TODO sorted insertion?\n\n  topology.objects.triangles.geometries.sort((a, b) => a.area - b.area);\n  return topology;\n}\nexport function collapseTopology(topology, numPieces) {\n  const geometries = topology.objects.triangles.geometries,\n        bisect = bisector(d => d.area).left;\n\n  while (geometries.length > numPieces) {\n    mergeSmallestFeature();\n  }\n\n  if (numPieces > geometries.length) {\n    throw new RangeError(\"Can't collapse topology into \" + numPieces + \" pieces.\");\n  }\n\n  return feature(topology, topology.objects.triangles).features.map(f => {\n    f.geometry.coordinates[0].pop();\n    return f.geometry.coordinates[0];\n  });\n\n  function mergeSmallestFeature() {\n    const smallest = geometries[0],\n          neighborIndex = neighbors(geometries)[0][0],\n          neighbor = geometries[neighborIndex],\n          merged = mergeArcs(topology, [smallest, neighbor]); // MultiPolygon -> Polygon\n\n    merged.area = smallest.area + neighbor.area;\n    merged.type = \"Polygon\";\n    merged.arcs = merged.arcs[0]; // Delete smallest and its chosen neighbor\n\n    geometries.splice(neighborIndex, 1);\n    geometries.shift(); // Add new merged shape in sorted order\n\n    geometries.splice(bisect(geometries, merged.area), 0, merged);\n  }\n}","map":null,"metadata":{},"sourceType":"module"}