{"ast":null,"code":"import normalizeRing from \"./normalize.js\";\nimport { addPoints } from \"./add.js\";\nimport rotate from \"./rotate.js\";\nimport { interpolatePoints } from \"./math.js\";\nexport default function (fromShape, toShape, {\n  maxSegmentLength = 10,\n  string = true\n} = {}) {\n  let fromRing = normalizeRing(fromShape, maxSegmentLength),\n      toRing = normalizeRing(toShape, maxSegmentLength),\n      interpolator = interpolateRing(fromRing, toRing, string); // Extra optimization for near either end with path strings\n\n  if (!string || typeof fromShape !== \"string\" && typeof toShape !== \"string\") {\n    return interpolator;\n  }\n\n  return t => {\n    if (t < 1e-4 && typeof fromShape === \"string\") {\n      return fromShape;\n    }\n\n    if (1 - t < 1e-4 && typeof toShape === \"string\") {\n      return toShape;\n    }\n\n    return interpolator(t);\n  };\n}\nexport function interpolateRing(fromRing, toRing, string) {\n  let diff;\n  diff = fromRing.length - toRing.length; // TODO bisect and add points in one step?\n\n  addPoints(fromRing, diff < 0 ? diff * -1 : 0);\n  addPoints(toRing, diff > 0 ? diff : 0);\n  rotate(fromRing, toRing);\n  return interpolatePoints(fromRing, toRing, string);\n}","map":null,"metadata":{},"sourceType":"module"}