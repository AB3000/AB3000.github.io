{"ast":null,"code":"import { polygonArea } from \"d3-polygon\";\nimport { pathStringToRing } from \"./svg.js\";\nimport { samePoint, isFiniteNumber } from \"./math.js\";\nimport { bisect } from \"./add.js\";\nimport { INVALID_INPUT } from \"./errors.js\";\nexport default function normalizeRing(ring, maxSegmentLength) {\n  let points, area, skipBisect;\n\n  if (typeof ring === \"string\") {\n    let converted = pathStringToRing(ring, maxSegmentLength);\n    ring = converted.ring;\n    skipBisect = converted.skipBisect;\n  } else if (!Array.isArray(ring)) {\n    throw new TypeError(INVALID_INPUT);\n  }\n\n  points = ring.slice(0);\n\n  if (!validRing(points)) {\n    throw new TypeError(INVALID_INPUT);\n  } // TODO skip this test to avoid scale issues?\n  // Chosen epsilon (1e-6) is problematic for small coordinate range\n\n\n  if (points.length > 1 && samePoint(points[0], points[points.length - 1])) {\n    points.pop();\n  }\n\n  area = polygonArea(points); // Make all rings clockwise\n\n  if (area > 0) {\n    points.reverse();\n  }\n\n  if (!skipBisect && maxSegmentLength && isFiniteNumber(maxSegmentLength) && maxSegmentLength > 0) {\n    bisect(points, maxSegmentLength);\n  }\n\n  return points;\n}\n\nfunction validRing(ring) {\n  return ring.every(function (point) {\n    return Array.isArray(point) && point.length >= 2 && isFiniteNumber(point[0]) && isFiniteNumber(point[1]);\n  });\n}","map":null,"metadata":{},"sourceType":"module"}