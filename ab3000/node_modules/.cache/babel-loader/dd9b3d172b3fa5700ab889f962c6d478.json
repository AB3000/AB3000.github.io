{"ast":null,"code":"import _slicedToArray from \"/Users/sparkle968/Documents/GitHub/AB3000.github.io/ab3000/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport Path from \"svgpath\";\nimport { svgPathProperties } from \"svg-path-properties\";\nimport normalizeRing from \"./normalize.js\";\nimport { isFiniteNumber } from \"./math.js\";\nimport { INVALID_INPUT } from \"./errors.js\";\n\nfunction parse(str) {\n  return new Path(str).abs();\n}\n\nfunction split(parsed) {\n  return parsed.toString().split(\"M\").map((d, i) => {\n    d = d.trim();\n    return i && d ? \"M\" + d : d;\n  }).filter(d => d);\n}\n\nexport function toPathString(ring) {\n  return \"M\" + ring.join(\"L\") + \"Z\";\n}\nexport function splitPathString(str) {\n  return split(parse(str));\n}\nexport function pathStringToRing(str, maxSegmentLength) {\n  let parsed = parse(str);\n  return exactRing(parsed) || approximateRing(parsed, maxSegmentLength);\n}\n\nfunction exactRing(parsed) {\n  let segments = parsed.segments || [],\n      ring = [];\n\n  if (!segments.length || segments[0][0] !== \"M\") {\n    return false;\n  }\n\n  for (let i = 0; i < segments.length; i++) {\n    let _segments$i = _slicedToArray(segments[i], 3),\n        command = _segments$i[0],\n        x = _segments$i[1],\n        y = _segments$i[2];\n\n    if (command === \"M\" && i || command === \"Z\") {\n      break;\n    } else if (command === \"M\" || command === \"L\") {\n      ring.push([x, y]);\n    } else if (command === \"H\") {\n      ring.push([x, ring[ring.length - 1][1]]);\n    } else if (command === \"V\") {\n      ring.push([ring[ring.length - 1][0], x]);\n    } else {\n      return false;\n    }\n  }\n\n  return ring.length ? {\n    ring\n  } : false;\n}\n\nfunction approximateRing(parsed, maxSegmentLength) {\n  let ringPath = split(parsed)[0],\n      ring = [],\n      props,\n      len,\n      m,\n      numPoints = 3;\n\n  if (!ringPath) {\n    throw new TypeError(INVALID_INPUT);\n  }\n\n  m = measure(ringPath);\n  len = m.getTotalLength();\n\n  if (maxSegmentLength && isFiniteNumber(maxSegmentLength) && maxSegmentLength > 0) {\n    numPoints = Math.max(numPoints, Math.ceil(len / maxSegmentLength));\n  }\n\n  for (let i = 0; i < numPoints; i++) {\n    let p = m.getPointAtLength(len * i / numPoints);\n    ring.push([p.x, p.y]);\n  }\n\n  return {\n    ring,\n    skipBisect: true\n  };\n}\n\nfunction measure(d) {\n  // Use native browser measurement if running in browser\n  if (typeof window !== \"undefined\" && window && window.document) {\n    try {\n      let path = window.document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n      path.setAttributeNS(null, \"d\", d);\n      return path;\n    } catch (e) {}\n  } // Fall back to svg-path-properties\n\n\n  return svgPathProperties(d);\n}","map":null,"metadata":{},"sourceType":"module"}