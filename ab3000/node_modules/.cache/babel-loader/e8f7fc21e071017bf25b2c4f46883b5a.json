{"ast":null,"code":"import { interpolateRing } from \"./interpolate.js\";\nimport { toPathString } from \"./svg.js\";\nimport { addPoints } from \"./add.js\";\nimport normalizeRing from \"./normalize.js\";\nimport triangulate from \"./triangulate.js\";\nimport pieceOrder from \"./order.js\";\nimport { INVALID_INPUT_ALL } from \"./errors.js\";\nexport function separate(fromShape, toShapes, {\n  maxSegmentLength = 10,\n  string = true,\n  single = false\n} = {}) {\n  let fromRing = normalizeRing(fromShape, maxSegmentLength);\n\n  if (fromRing.length < toShapes.length + 2) {\n    addPoints(fromRing, toShapes.length + 2 - fromRing.length);\n  }\n\n  let fromRings = triangulate(fromRing, toShapes.length),\n      toRings = toShapes.map(d => normalizeRing(d, maxSegmentLength)),\n      t0 = typeof fromShape === \"string\" && fromShape,\n      t1;\n\n  if (!single || toShapes.every(s => typeof s === \"string\")) {\n    t1 = toShapes.slice(0);\n  }\n\n  return interpolateSets(fromRings, toRings, {\n    match: true,\n    string,\n    single,\n    t0,\n    t1\n  });\n}\nexport function combine(fromShapes, toShape, {\n  maxSegmentLength = 10,\n  string = true,\n  single = false\n} = {}) {\n  let interpolators = separate(toShape, fromShapes, {\n    maxSegmentLength,\n    string,\n    single\n  });\n  return single ? t => interpolators(1 - t) : interpolators.map(fn => t => fn(1 - t));\n}\nexport function interpolateAll(fromShapes, toShapes, {\n  maxSegmentLength = 10,\n  string = true,\n  single = false\n} = {}) {\n  if (!Array.isArray(fromShapes) || !Array.isArray(toShapes) || fromShapes.length !== toShapes.length || !fromShapes.length) {\n    throw new TypeError(INVALID_INPUT_ALL);\n  }\n\n  let normalize = s => normalizeRing(s, maxSegmentLength),\n      fromRings = fromShapes.map(normalize),\n      toRings = toShapes.map(normalize),\n      t0,\n      t1;\n\n  if (single) {\n    if (fromShapes.every(s => typeof s === \"string\")) {\n      t0 = fromShapes.slice(0);\n    }\n\n    if (toShapes.every(s => typeof s === \"string\")) {\n      t1 = toShapes.slice(0);\n    }\n  } else {\n    t0 = fromShapes.slice(0);\n    t1 = toShapes.slice(0);\n  }\n\n  return interpolateSets(fromRings, toRings, {\n    string,\n    single,\n    t0,\n    t1,\n    match: false\n  });\n}\n\nfunction interpolateSets(fromRings, toRings, {\n  string,\n  single,\n  t0,\n  t1,\n  match\n} = {}) {\n  let order = match ? pieceOrder(fromRings, toRings) : fromRings.map((d, i) => i),\n      interpolators = order.map((d, i) => interpolateRing(fromRings[d], toRings[i], string));\n\n  if (match && Array.isArray(t0)) {\n    t0 = order.map(d => t0[d]);\n  }\n\n  if (single && string) {\n    if (Array.isArray(t0)) {\n      t0 = t0.join(\" \");\n    }\n\n    if (Array.isArray(t1)) {\n      t1 = t1.join(\" \");\n    }\n  }\n\n  if (single) {\n    let multiInterpolator = string ? t => interpolators.map(fn => fn(t)).join(\" \") : t => interpolators.map(fn => fn(t));\n\n    if (string && (t0 || t1)) {\n      return t => t < 1e-4 && t0 || 1 - t < 1e-4 && t1 || multiInterpolator(t);\n    }\n\n    return multiInterpolator;\n  } else if (string) {\n    t0 = Array.isArray(t0) ? t0.map(d => typeof d === \"string\" && d) : [];\n    t1 = Array.isArray(t1) ? t1.map(d => typeof d === \"string\" && d) : [];\n    return interpolators.map((fn, i) => {\n      if (t0[i] || t1[i]) {\n        return t => t < 1e-4 && t0[i] || 1 - t < 1e-4 && t1[i] || fn(t);\n      }\n\n      return fn;\n    });\n  }\n\n  return interpolators;\n}","map":null,"metadata":{},"sourceType":"module"}